# Setup Experience, Thoughts, Pain Points and Comments

In this essay, we will recount our experience running C.E.L.T.: The Sentimental Analyzer, highlighting the difficulties encountered and the valuable lessons learned. The project aims to predict user sentiment using various methods, such as document analysis, text analysis, product analysis, and audio analysis. While the project has great potential, several obstacles arose during our attempt to run it.
  
One of the initial challenges we faced was the outdated [requirements.txt file](https://github.com/mrpudlo/SE_Project1/blob/master/requirements.txt). This file is crucial for specifying project dependencies, but it appeared that some of the modules listed were no longer compatible or were missing from the Python Package Index (PyPI). This led to installation errors and a frustrating start to the project. One of the module urls was deprecated, and the keyword used to define it had been changed in the new version. This type of huge change shows that the modules described in requirements.txt are very outdated. Keeping dependencies up-to-date is vital in software development. In project 2, we will ensure that the requirements.txt file is regularly maintained, and we will be cautious about relying on older or deprecated libraries. We will make sure to use different measures to prevent this type of problem. Some of the measures include using version constraints, using Pipenv, or regularly updating dependencies manually.
  
Another significant issue was the presence of hardcoded paths in many of the project's scripts. For example, line number 16 in [amazon_test.py](https://github.com/mrpudlo/SE_Project1/blob/master/sentimental_analysis/realworld/amazon_test.py): These paths made it challenging to set up the project on different systems, as they assumed specific directory structures or locations for data and resources. The use of relative or environment-variable-based paths will make the project more portable and accessible to the developers.
  
The project's documentation is lacking in detail. While it mentioned the necessary technologies and provided high-level execution steps, it did not delve into the intricacies of the project's architecture, code structure, or specific requirements for different methods of sentiment analysis. The documentation does not tell a story; it does not have any images; it does not have mini-tutorials for each type of analysis; and it also does not specify the code structure. A well-structured repository is not only visually appealing, but it also aids in code organization and comprehension. Because there was no clear and logical file organization, team members and potential contributors became confused. It made it difficult for them to discover certain code components and comprehend the project's design. The code file structure should have been specified early in the project's lifespan to avoid this discomfort.
  
We have studied many projects’ repo, and we have learned that comprehensive documentation is essential for project maintainability and collaboration. In project 2, we will prioritize detailed documentation, including code explanations, architecture diagrams, and clear instructions for setup and usage, which will make other developers dive into this project’s development.
  
The user interface lacks modern design elements and user-friendly features, which could affect the project's usability and user experience. In software development, a well-designed UI is crucial for user engagement. So, we will pay more attention to the UI design and consider using front-end frameworks like Bootstrap to enhance the user experience.
  
C.E.L.T. includes a feature for the product’s sentiment analysis that was not functioning during our attempts to run it. Thorough testing and validation of all project features are essential. In project 2, we will make it functional and test it thoroughly.
  
Another project's pain point was the lack of necessary badges in the GitHub repository. Badges for open/closed issues, contributions, code coverage, and programming language used, for example, are critical for delivering transparency and credibility to an open-source project. The lack of these symbols made it difficult for users to quickly judge the project's status, potentially leading to suspicion or disinterest.
  
An easy approach would have been to incorporate these badges from the beginning. GitHub provides clear instructions for adding badges to a repository's README, making it a simple operation. In the upcoming project, we commit to putting the required badges in the repository's README from the start.
  
We are committed to proactively defining and sticking to a well-structured code file organization scheme in subsequent initiatives. This entails building folders and subfolders for various code modules and providing a clear README with a directory structure description. Furthermore, clarifying the purpose and function of each folder and file makes it easier for team members and contributors to browse the repository.
  
The challenges mentioned above have taught us valuable lessons, and we will be using these lessons in Project 2. We will prioritize regular maintenance of dependencies, avoid hardcoded paths, create comprehensive documentation, focus on user-friendly UI design, and rigorously test all features.
